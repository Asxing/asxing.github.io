---
title: Java进阶之JVM实战
author: HoldDie
top: false
cover: false
toc: true
mathjax: true
tags:
  - Java
  - JVM
date: 2021-02-24 14:42:59
img:
coverImg:
password:
summary:
categories: Java进阶
---



## 1. 使用自定义Classloader机制，实现xlass的加载

### 1.1 类加载流程

#### BootStrap 加载路径

```java
System.getProperty("sun.boot.class.path")

输出结果如下：
xxx/jre/lib/resources.jar: 
xxx/jre/lib/rt.jar: 
xxx/jre/lib/sunrsasign.jar: 
xxx/jre/lib/jsse.jar: 
xxx/jre/lib/jce.jar: 
xxx/jre/lib/charsets.jar: 
xxx/jre/lib/jfr.jar: 
xxx/jre/classes
```

#### ExtClassLoader 加载路径

```java
System.getProperty("java.ext.dirs")

输出结果如下：
/Users/xxx/Library/Java/Extensions:
xxx/jre/lib/ext:
/Library/Java/Extensions:
/Network/Library/Java/Extensions:
/System/Library/Java/Extensions:
/usr/lib/java
```

#### AppClassLoader 加载路径

```java
System.out.println("自定义类加载路径：");
System.out.println(AXClassLoader.class.getClassLoader());
System.out.println("对应Parent ClassLoader：");
System.out.println(AXClassLoader.getSystemClassLoader().getParent());
// 虽然结果为null，但是我们知道此时应该为启动类
System.out.println("对应父类的父类 ClassLoader：");
System.out.println(AXClassLoader.getSystemClassLoader().getParent().getParent());
```

### 1.2 Java Resource 路径

```java
private static void printResourcePath() {
    System.out.println("AXClassLoader.class.getResource(\"\")):\n" + AXClassLoader.class.getResource(""));
    System.out.println("AXClassLoader.class.getResource(\"/\")):\n" + AXClassLoader.class.getResource("/"));
    System.out.println("AXClassLoader.class.getClassLoader().getResource(\"\")):\n" + AXClassLoader.class.getClassLoader().getResource(""));
    System.out.println("ClassLoader.getSystemResource(\"))\n" + ClassLoader.getSystemResource(""));
    System.out.println("Thread.currentThread().getContextClassLoader().getResource(\"\")\n" + Thread.currentThread().getContextClassLoader().getResource(""));
}

输出结果：
AXClassLoader.class.getResource("")):
file:/Users/zeyangg/SynologyDrive/ww/java-p7-in-action/jvm-base/target/classes/com/holddie/jvm/classloader/v1/

AXClassLoader.class.getResource("/")):
file:/Users/zeyangg/SynologyDrive/ww/java-p7-in-action/jvm-base/target/classes/

AXClassLoader.class.getClassLoader().getResource("")):
file:/Users/zeyangg/SynologyDrive/ww/java-p7-in-action/jvm-base/target/classes/

ClassLoader.getSystemResource("))
file:/Users/zeyangg/SynologyDrive/ww/java-p7-in-action/jvm-base/target/classes/

Thread.currentThread().getContextClassLoader().getResource("")
file:/Users/zeyangg/SynologyDrive/ww/java-p7-in-action/jvm-base/target/classes/
```

#### 1.3 实现 AXClassLoader 定义

```java
public class AXClassLoader extends ClassLoader {

  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
    try {
      byte[] bytes = Files.readAllBytes(Paths.get(getFileName(name)));
      // 由于 xlass 在生成的时候使用了特殊规则，所以在加载完之后，需要恢复回去
      for (int i = 0; i < bytes.length; i++) {
        bytes[i] = (byte) (255 - bytes[i]);
      }
      return defineClass(name, bytes, 0, bytes.length);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return super.findClass(name);
  }

  private String getFileName(String name) {
    int index = name.lastIndexOf('.');
    if (index == -1) {
      return ClassLoader.getSystemResource("").getPath() + name + ".xlass";
    } else {
      return ClassLoader.getSystemResource("").getPath() + name.substring(index + 1) + ".xlass";
    }
  }
}
```

#### 1.4 调用加载

```java
/*
 * 自定义加载器加载
 */
AXClassLoader axClassLoader = new AXClassLoader();
try {
    Class<?> hello = axClassLoader.loadClass("Hello");
    if (hello != null) {
        Object obj = hello.newInstance();
        Method method = hello.getDeclaredMethod("hello");
        method.invoke(obj);
    }
} catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) {
    e.printStackTrace();
}
```

## 2. 实现xlass打包的xar（类似class文件打包的jar）的加载

#### 2.1 生成 xar 包

```java
private static void createHelloXar() {
  try {
    XarSink xarSink = new XarSink();
    final XarFileSource fileSource;
    final File fileToCompress = getClasspathResourceAsFile(CLASS_FILE_NAME);
    assert fileToCompress != null;
    fileSource = new XarFileSource(fileToCompress);
    xarSink.addSource(fileSource);
    URL resource = Thread.currentThread().getContextClassLoader().getResource("");
    assert resource != null;
    xarSink.write(FileUtils.openOutputStream(new File(resource.getPath(), XAR_FILE_NAME)));
  } catch (Exception e) {
    e.printStackTrace();
  }
}
```

#### 2.2 解析 xar 包

```java
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
  try {
    XarSource xar = new FileXarSource(getClasspathResourceAsFile(name));
    XarEntry entry = xar.getEntry(CLASS_FILE_NAME);
    byte[] bytes = entry.getBytes();
    // 由于 xlass 在生成的时候使用了特殊规则，所以在加载完之后，需要恢复回去
    for (int i = 0; i < bytes.length; i++) {
      bytes[i] = (byte) (255 - bytes[i]);
    }
    return defineClass(CLASS_NAME, bytes, 0, bytes.length);
  } catch (IOException | URISyntaxException e) {
    e.printStackTrace();
  }
  return super.findClass(name);
}
```

#### 2.3 加载 xar 包

```java
/*
 *自定义加载 xar 文件
 */
AXClassLoader axClassLoader = new AXClassLoader();
try {
  Class<?> hello = axClassLoader.loadClass(XAR_FILE_NAME);
  if (hello != null) {
    Object obj = hello.newInstance();
    Method method = hello.getDeclaredMethod(METHOD_NAME);
    method.invoke(obj);
  }
} catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) {
  e.printStackTrace();
}
```

## 3. 基于自定义Classloader实现类的动态加载和卸载

#### 3.1 理论支撑

如何实现类的卸载，需要满足哪些条件：

- 该类的所有实例对象不可达
- 该类的Class对象不可达
- 该类的ClassLoader不可达

使用什么方式监控JVM的加载和卸载过程？

- `-verbose:class` ：同时追踪类的加载和卸载
- `-XX:+TraceClassLoading`：单独跟踪类的加载
- `-XX:+TranceUnloading`：单独跟踪累的卸载

类加载器特征

- 每个ClassLoader都维护了一份自己的名称空间，同一个名称空间里不能出现两个同名的类；
- 为了实现Java安全沙箱模型的类加载安全机制，Java默认采用了“双亲委派的加载链”结构；

#### 3.2 



## 参考链接

- 