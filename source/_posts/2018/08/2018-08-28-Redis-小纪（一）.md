---
title: Redis-小纪（一）
tags: [Redis, 分布式]
img: https://www.holddie.com/img/20200105162523.jpg
date: 2018-08-28 09:47:07
categories: Redis
---

人生如梦，始终都逃不过当局者迷的悲哀。																	——融融



#### Redis 线程模型

- 简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。

- 在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

- 需要说明的是，这个 I/O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库。

#### Redis 的过期策略以及内存淘汰机制

> Redis  采用定期删除+惰性删除策略

- 检查定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。

- 需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。

- 因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。

- 也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

##### 使用这种方式存在问题：

如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。

在 `redis.conf` 中配置文件，该配置就是配内存淘汰策略：

- **noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
- **allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。
- **allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
- **volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
- **volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
- **volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。

#### **Redis** 和 **数据库** 双写一致性的问题

- 分布式环境下一致性问题，分为最终一致性和强一致性，数据库和缓存双写必然会存在不一致的问题。
- 共识，如果对数据有强一致性要求，不能放缓存，使用缓存所做的一切，只能保证最终一致性。
- 我们所采取的策略只能降低不一致发生的概率，无法完全避免，因此有强一致性要求的数据，不能放缓存。
- 做法：
  - 采取正确的缓存策略
  - 先更新数据库
  - 再删除缓存，其次对于可能存在删除缓存失败的时候，提供一个补偿措施（使用消息队列）

#### Redis  缓存穿透 和 缓存雪崩

- 缓存穿透：故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库异常。
- 缓存穿透的解决方案：
  - 利用互斥锁：缓存失效的时候，先去获得锁，得到锁的去请求数据库，没有得到锁的，休眠一段时间重试。
  - 采用异步更新策略，无论key是否取到值，都直接返回。缓存中维护一个缓存失效时间，缓存如果过期，则异步起一个线程去读数据库，更新缓存。需要做缓存预热（在项目启动前，先加载缓存）
  - 提供一个可以迅速判断请求是否有效的拦截机制，每个请求有一个特殊合法的key，我们可以迅速判断，是否有效，进行过滤。
- 缓存雪崩：同一个时间，大量的缓存同时失效，当此时有一波请求，都会访问到底层的数据库上，从而导致数据库连接异常。
- 缓存雪崩解决方法：
  - 缓存失效时间：在设置缓存的失效时间的时候，加上一个随机数，避免集体失效。
  - 使用互斥锁：该方案吞吐量明显下降
  - 双缓存：我们设置两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设置失效时间，自己所预热操作。然后，从缓存A中读取数据库，有则直接返回；A中没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程，同时更新缓存A和缓存B。

#### Redis  并发竞争 key 问题

- 通常做法就是使用Redis事务机制，但是在实际操作中，我们一个事务中可能涉及到多个Key操作的时候，此时这些key可能存在不同的redis-server上，此时使用事务有点鸡肋。

##### 对key操作，不要求顺序

- 这种情况下，准备一个分布式锁，大家轮流去抢，抢到锁就做set操作即可。

##### 对key操作，要求顺序

- 对于不同的操作，我们在操作前，可以使用时间戳进行判断，当同事三个人都想要对key操作，首先进行竞争，然后进去比较时间戳，若比当前时间大，我们就进行更新，否则不更新。

