---
title: 高性能MySQL-MySQL架构与历史（一）
author: HoldDie
img: https://www.holddie.com/img/20200209200559.jpg
top: false
cover: false
coverImg: https://www.holddie.com/img/20200209200559.jpg
toc: true
mathjax: true
tags:
  - 读书
  - MySQL
date: 2020-02-09 20:01:10
password: 
summary: 
categories: MySQL
---



![](https://www.holddie.com/img/20200209200559.jpg)



## 第1章　MySQL架构与历史

>  MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。

### 1.1　MySQL逻辑架构

- 最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- 第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。
- 1.1.1　连接管理与安全性

  - 每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。
  - 服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程(2)。

- 1.1.2　优化与执行

  - MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。
  - 用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程。
  - 可以请求优化器解释（explain）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。
  - 优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。
  - 优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。
  - 对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

### 1.2　并发控制

- 无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。
- MySQL在两个层面的并发控制：服务器层与存储引擎层。
- 1.2.1　读写锁

  - 并发控制，其实非常简单。在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。
  - 读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。
  - 写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

- 1.2.2　锁粒度

  - 任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。
  - 所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

- 表锁（table lock）

  - 表锁非常类似于前文描述的邮箱加锁机制：它会锁定整张表。
  - 一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。
  - 只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。
  - 写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面

- 行级锁（row lock）

  - 行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。
  - 行级锁只在存储引擎层实现，而MySQL服务器层（如有必要，请回顾前文的逻辑架构图）没有实现。

### 1.3　事务

- 事务内的语句，要么全部执行成功，要么全部执行失败。
- 可以用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交事务将修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。
- ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。
- 原子性（atomicity）一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
- 一致性（consistency）数据库总是从一个一致性的状态转换到另外一个一致性的状态。
- 隔离性（isolation）通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性（durability）一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。
- 1.3.1　隔离级别

  - 四种隔离级别。

    - READ UNCOMMITTED（未提交读）

      - 在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。

    - READ COMMITTED（提交读）

      - 大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。
      - READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。

    - REPEATABLE READ（可重复读）

      - REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。
      - 所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。
      - InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。
      - 可重复读是MySQL的默认事务隔离级别。

    - SERIALIZABLE（可串行化）

      - SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。
      - Subtopic

- 1.3.2　死锁

  - 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象
  - 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。
  - 多个事务同时锁定同一个资源时，也会产生死锁。
  - 为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。
  - 越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。
  - 还有一种解决方式，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。
  - InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。
  - 锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。
  - 死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。
  - 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。
  - 对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

- 1.3.3　事务日志

  - 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
  - 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。
  - 事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。
  - 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

- 1.3.4　MySQL中的事务

  - 自动提交（AUTOCOMMIT）

    - MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。
    - MySQL能够识别所有的4个ANSI隔离级别，InnoDB引擎也支持所有的隔离级别。

  - 在事务中混合使用存储引擎

    - MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

  - 隐式和显式锁定

    - InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。
    - InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范(3)：
    - SELECT ... LOCK IN SHARE MODE
    - SELECT ... FOR UPDATE
    - MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。
    - 应用已经将表从MyISAM转换到InnoDB，但还是显式地使用LOCK TABLES语句。这不但没有必要，还会严重影响性能，实际上InnoDB的行级锁工作得更好。
    - LOCK TABLES和事务之间相互影响的话，情况会变得非常复杂，在某些MySQL版本中甚至会产生无法预料的结果。因此，本书建议，除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎。

### 1.4　多版本并发控制

- MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。
- MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
- InnoDB的简化版行为来说明MVCC是如何工作的。
- InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。
- 当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。
- 事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
- 在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

  - SELECT InnoDB会根据以下两个条件检查每行记录：InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
    行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
     只有符合上述两个条件的记录，才能返回作为查询结果。
  - INSERT InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
  - DELETE InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
  - UPDATE InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
  - MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。
  - 其他两个隔离级别都和MVCC不兼容(4)，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。

### 1.5　MySQL的存储引擎

- 在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据目录下的一个子目录。
- 创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。
- 因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。
- 在Windows中，大小写是不敏感的；而在类Unix中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。
- 1.5.1　InnoDB存储引擎

  - InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况是正常提交的，很少会被回滚
  - InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。
  - InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。
  - 间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
  - InnoDB的索引结构和MySQL的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

- 1.5.2　MyISAM存储引擎

  - 在MySQL 5.1及之前的版本，MyISAM是默认的存储引擎。
  - MyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。
  - MyISAM会将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为扩展名。
  - MyISAM表可以包含动态或者静态（长度固定）行。
  - MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。

- 1.5.3　MySQL内建的其他存储引擎

  - Archive引擎

    - Archive存储引擎只支持INSERT和SELECT操作，在MySQL 5.1之前也不支持索引。
    - Archive引擎会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少。但是每次SELECT查询都需要执行全表扫描。

  - Blackhole引擎

    - Blackhole引擎没有实现任何的存储机制，它会丢弃所有插入的数据，不做任何保存。但是服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。

  - CSV引擎

    - CSV引擎可以将普通的CSV文件（逗号分割值的文件）作为MySQL的表来处理，但这种表不支持索引。CSV引擎可以在数据库运行时拷入或者拷出文件。

  - Federated引擎

    - Federated引擎是访问其他MySQL服务器的一个代理，它会创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。

  - Memory引擎

    - 如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表（以前也叫做HEAP表）是非常有用的。Memory表至少比MyISAM表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。

  - Merge引擎

    - Merge引擎是MyISAM引擎的一个变种。Merge表是由多个MyISAM表合并而来的虚拟表。如果将MySQL用于日志或者数据仓库类应用，该引擎可以发挥作用。但是引入分区功能后，该引擎已经被放弃（参考第7章）。

  - NDB集群引擎

    - 2003年，当时的MySQL AB公司从索尼爱立信公司收购了NDB数据库，然后开发了NDB集群存储引擎，作为SQL和NDB原生协议之间的接口。

- 1.5.4　第三方存储引擎

### 1.6　MySQL时间线（Timeline）

- 版本3.23（2001）
- 版本4.0（2003）
- 版本4.1（2005）
- 版本5.0（2006）
- 版本5.1（2008）
- 版本5.5（2010）

### 1.7　MySQL的开发模式

- MySQL依然遵循GPL开源协议，全部的源代码（除了一些商业版本的插件）都会开放给社区。
- 无论如何，不开源的扩展也只是扩展而已，并不会将MySQL变成受限制的非开源模式。没有这些扩展，MySQL也是功能完整的数据库。

### 1.8　总结

- MySQL拥有分层的架构，上层是服务器层的服务和查询执行引擎，下层则是存储引擎。
- InnoDB对于95％以上的用户来说都是最佳选择

