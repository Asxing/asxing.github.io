---
title: 高性能MySQL-查询性能优化（五）
author: HoldDie
img: https://www.holddie.com/img/20200308213418.png
top: false
cover: false
coverImg: https://www.holddie.com/img/20200308213418.png
toc: true
mathjax: true
tags:
  - MySQL
  - 查询
date: 2020-03-08 21:30:14
password:
summary: 对于SQL查询，真正重要是响应时间。
categories: MySQL
---



![](https://www.holddie.com/img/20200308213418.png)

## 第6章　查询性能优化

### 6.1　为什么查询速度会慢

- 对于SQL查询，真正重要是响应时间。
- 如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。
- 如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快(1)。
- 查询的生命周期大致可以按照顺序来看：
  - 从客户端，到服务器
  - 然后在服务器上进行解析
  - 生成执行计划
  - 执行
  - 返回结果给客户端
- 在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。
- 根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。
- 在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。
- 优化查询的目的就是减少和消除这些操作所花费的时间。

### 6.2　慢查询基础：优化数据访问

- 查询性能低下最基本的原因是访问的数据太多。

- 大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。

- 对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。

- 确认MySQL服务器层是否在分析大量超过需要的数据行。

  

#### 6.2.1　是否向数据库请求了不需要的数据

- 查询不需要的记录，最简单有效的解决方法就是在这样的查询后面加上LIMIT。
- 多表关联时返回全部列
- 总是取出全部列，取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗。
- 重复查询相同的数据

#### 6.2.2　MySQL是否在扫描额外的记录

- 在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：响应时间扫描的行数返回的行数
- 检查慢日志记录是找出扫描行数过多的查询的好办法。

###### 响应时间

- 响应时间是两个部分之和：服务时间和排队时间。
- 服务时间是指数据库处理这个查询真正花了多长时间。
- 排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。

###### 扫描的行数和返回的行数

- 分析查询时，查看该查询扫描的行数是非常有帮助的。
- 理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大。

###### 扫描的行数和访问类型

- 在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。你不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围访问和单值访问的概念。
- 如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。
- 索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。

- 一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：

  - 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。
  - 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。
  - 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。
  - MySQL不会告诉我们生成结果实际上需要扫描多少行数据(4)，而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终的结果集并没有贡献。

- 如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：

  - 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了
  - 改变库表结构。例如使用单独的汇总表
  - 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询

### 6.3　重构查询的方式

#### 6.3.1　一个复杂查询还是多个简单查询

- MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。
- MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySQL响应数据给客户端就慢得多了。
- 在应用设计的时候，如果一个查询能够胜任时还写成多个独立查询是不明智的。

#### 6.3.2　切分查询

- 定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
- 将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。
- `mysql> DELETE FROM messages WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH); `
- 可以用下面的办法来替换：
- `rows_affected = 0 do { rows_affected = do_query( "DELETE FROM messages WHERE created < DATE_SUB(NOW(),INTERVAL 3 MONTH) LIMIT 10000") } while rows_affected > 0`
- 如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。

#### 6.3.3　分解关联查询

- 分解关联查询的方式重构查询有如下的优势：

  - 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。
  - 将查询分解后，执行单个查询可以减少锁的竞争。
  - 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
  - 查询本身效率也可能会有所提升。
  - 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。
  - 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多