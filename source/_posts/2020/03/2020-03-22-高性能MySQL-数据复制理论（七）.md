---
title: 高性能MySQL-数据复制理论（七）
author: HoldDie
img: https://www.holddie.com/img/20200322225345.png
top: false
cover: false
coverImg: https://www.holddie.com/img/20200322225345.png
toc: true
mathjax: true
tags:
  - MySQL
  - 数据复制
date: 2020-03-22 22:41:43
password:
summary: 复制功能不仅有利于构建高性能的应用，同时也是高可用性、可扩展性、灾难恢复、备份以及数据仓库等工作的基础。
categories: MySQL
---

![](https://www.holddie.com/img/20200322225345.png)

## 第10章　复制

- 复制功能不仅有利于构建高性能的应用，同时也是高可用性、可扩展性、灾难恢复、备份以及数据仓库等工作的基础。

### 10.1　复制概述

- 复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。
- 一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。
- MySQL支持两种复制方式：基于行的复制和基于语句的复制。
- 基于语句的复制（也称为逻辑复制）早在MySQL 3.23版本中就存在
- 基于行的复制方式在5.1版本中才被加进来。
- MySQL复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库
- 复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这点开销也是必要的。
- 通过复制可以将读操作指向备库来获得更好的读扩展，但对于写操作，除非设计得当，否则并不适合通过复制来扩展写操作。在一主库多备库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的那部分。

#### 10.1.1　复制解决的问题

- 数据分布

  - MySQL复制通常不会对带宽造成很大的压力，但在5.1版本引入的基于行的复制会比传统的基于语句的复制模式的带宽压力更大

- 负载均衡

  - 通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，并且实现很方便，通过简单的代码修改就能实现基本的负载均衡。

- 备份

  - 对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能够取代备份。

- 高可用性和故障切换

  - 复制能够帮助应用程序避免MySQL单点失败，一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间

#### 10.1.2　复制如何工作

- 复制有三个步骤：

  - 在主库上把数据更改记录到二进制日志（Binary Log）中（这些记录被称为二进制日志事件）。
    - 在主库上记录二进制日志，在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。
  - 备库将主库上的日志复制到自己的中继日志（Relay Log）中。
    - 备库将主库的二进制日志复制到其本地的中继日志中。
    - 首先，备库会启动一个工作线程，称为I/O线程，I/O线程跟主库建立一个普通的客户端连接，
    - 然后在主库上启动一个特殊的二进制转储（binlog dump）线程（该线程没有对应的SQL命令），这个二进制转储线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。
    - 如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库I/O线程会将接收到的事件记录到中继日志中。
  - 备库读取中继日志中的事件，将其重放到备库数据之上。

    - 备库的SQL线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。

### 10.2　配置复制

#### 10.2.1　创建复制账号

#### 10.2.2　配置主库和备库

- 主库的my.cnf文件中增加或修改如下内容：`mysql-bin server_id   = 10`
- 备库上也需要在my.cnf中增加类似的配置，并且同样需要重启服务器。
  - `mysql-bin server_id         = 2 `
  - `relay_log         = /var/lib/mysql/mysql-relay-bin| Chapter 10:Chapter 10: Replication Replicationlog_slave_updates = 1 `
  - `read_only         = 1`
- relay_log（指定中继日志的位置和命名）
- log_slave_updates（允许备库将其重放的事件也记录到自身的二进制日志中）

#### 10.2.3　启动复制

- 开始复制的基本命令：

  - `CHANGE MASTER TO MASTER_HOST='server1', -> MASTER_USER='repl', -> MASTER_PASSWORD='p4ssword', -> MASTER_LOG_FILE='mysql-bin.000001', -> MASTER_LOG_POS=0;`

- 通过SHOW SLAVE STATUS语句来检查复制是否正确执行。
- SHOW PROCESSLIST

#### 10.2.4　从另一个服务器开始复制

- 需要有三个条件来让主库和备库保持同步：

  - 在某个时间点的主库的数据快照。
  - 主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中的偏移量，我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。可以通过SHOW MASTER STATUS命令来获取这些值。
  - 从快照时间到现在的二进制日志。

- 使用冷备份

  - 最基本的方法是关闭主库，把数据复制到备库（高效复制文件的方法参考附录C）。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行CHANGE MASTER TO指向这个文件的起始处。这个方法的缺点很明显：在复制数据时需要关闭主库。

- 使用热备份

  - 如果仅使用了MyISAM表，可以在主库运行时使用mysqlhotcopy或rsync来复制数据，

- 使用mysqldump

  - 如果只包含InnoDB表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置相应的二进制日志坐标：$ mysqldump --single-transaction --all-databases --master-data=1--host=server1 \ | mysql --host=server2

- 使用快照或备份

  - 只要知道对应的二进制日志坐标，就可以使用主库的快照或者备份来初始化备库（如果使用备份，需要确保从备份的时间点开始的主库二进制日志都要存在）。只需要把备份或快照恢复到备库，然后使用CHANGE MASTER TO指定二进制日志的坐标。

- 使用Percona Xtrabackup

  - Percona的Xtrabackup是一款开源的热备份工具，多年前我们就介绍过。它能够在备份时不阻塞服务器的操作，因此可以在不影响主库的情况下设置备库。可以通过克隆主库或另一个已存在的备库的方式来建立备库。

#### 10.2.5　推荐的复制配置

- 在主库上二进制日志最重要的选项是 `sync_binlog=1` 如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证在服务器崩溃时不会丢失事件。如果禁止该选项，服务器会少做一些工作，但二进制日志文件可能在服务器崩溃时损坏或丢失信息。在一个不需要作为主库的备库上，该选项带来了不必要的开销。它只适用于二进制日志，而非中继日志。
- 如果使用InnoDB，我们强烈推荐设置如下选项

  - `innodb_flush_logs_at_trx_commit=1 # Flush every log write`
  - `innodb_support_xa=1               # MySQL 5.0 and newer only`
  - `innodb_safe_binlog                # MySQL 4.1 only, roughly equivalent to # innodb_support_xa`
  - `log_bin=/var/lib/mysql/mysql-bin  # Good; specifies a path and base namelog_bin=/var/lib/mysql/mysql-bin  # Good; specifies a path and base name#log_bin                          # Bad; base name will be server's hostname #log_bin                          # Bad; base name will be server's hostname`

- 如果备库与主库的延迟很大，备库的I/O线程可能会写很多中继日志文件，SQL线程在重放完一个中继日志中的事件后会尽快将其删除（通过relay_log_purge选项来控制）。但如果延迟非常严重，I/O线程可能会把整个磁盘撑满。解决办法是配置relay_log_space_limit变量。如果所有中继日志的大小之和超过这个值，I/O线程会停止，等待SQL线程释放磁盘空间。

### 10.3　复制的原理

#### 10.3.1　基于语句的复制

- 当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。
- 最明显的好处是实现相当简单。理论上讲，简单地记录和执行这些语句，能够让主备保持同步。另一个好处是二进制日志里的事件更加紧凑，所以相对而言，基于语句的模式不会使用太多带宽。一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。另外mysqlbinlog工具（本章多处会提到）是使用基于语句的日志的最佳工具。
- 除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的SQL。例如，使用CURRENT_USER()函数的语句。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。
- 另外一个问题是更新必须是串行的。这需要更多的锁

#### 10.3.2　基于行的复制

- 最大的好处是可以正确地复制每一行。一些语句可以被更加有效地复制。
- UPDATE enormous_table SET col1 = 0;
- 由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每一行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大。并且会给主库上记录日志和复制增加额外的负载，更慢的日志记录则会降低并发度。
- 由于没有哪种模式对所有情况都是完美的，MySQL能够在这两种复制模式间动态切换。默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确地复制，就切换到基于行的复制模式。还可以根据需要来设置会话级别的变量binlog_format，控制二进制日志格式。

#### 10.3.3　基于行或基于语句：哪种更优

- 基于语句的复制模式的优点

  - 基于语句的方式执行复制的过程基本上就是执行SQL语句。这意味着所有在服务器上发生的变更都以一种容易理解的方式运行。这样当出现问题时可以很好地去定位。
  - 基于语句的复制方式一般允许更灵活的操作。

- 基于语句的复制模式的缺点

  - 如果正在使用触发器或者存储过程，就不要使用基于语句的复制模式，除非能够清楚地确定不会碰到复制问题。

- 基于行的复制模式的优点

  - 几乎没有基于行的复制模式无法处理的场景。对于所有的SQL构造、触发器、存储过程等都能正确执行。只是当你试图做一些诸如在备库修改表的schema这样的事情时才可能导致复制失败。
  - 这种方式同样可能减少锁的使用，因为它并不要求这种强串行化是可重复的。
  - 基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。你不需要查看一条语句去猜测它到底修改了哪些数据。在某种程度上，该模式能够更加清楚地知道服务器上发生了哪些更改，并且有一个更好的数据变更记录。另外在一些情况下基于行的二进制日志还会记录发生改变之前的数据，因此这可能有利于某些数据恢复。
  - 在很多情况下，由于无须像基于语句的复制那样需要为查询建立执行计划并执行查询，因此基于行的复制占用更少的CPU。

  - 在某些情况下，基于行的复制能够帮助更快地找到并解决数据不一致的情况。

- 基于行的复制模式的缺点

  - 由于语句并没有在日志里记录，因此无法判断执行了哪些SQL，除了需要知道行的变化外，这在很多情况下也很重要
  - 基于语句的日志在复制拓扑中将会被切换到基于行的模式。基于行的日志无法处理诸如在备库修改表的schema这样的情况，而基于语句的日志可以。
  - 在某些情况下，例如找不到要修改的行时，基于行的复制可能会导致复制停止，而基于语句的复制则不会。这也可以认为是基于行的复制的一个优点。该行为可以通过slave_exec_mode来进行配置。

#### 10.3.4　复制文件

- mysql-bin.index

  - 当在服务器上开启二进制日志时，同时会生成一个和二进制日志同名的但以.index作为后缀的文件，该文件用于记录磁盘上的二进制日志文件。这里的“index”并不是指表的索引，而是说这个文件的每一行包含了二进制文件的文件名。
  - MySQL依赖于这个文件，除非在这个文件里有记录，否则MySQL识别不了二进制日志文件。

- mysql-relay-bin-index

  - 这个文件是中继日志的索引文件，和mysql-bin.index的作用类似。

- master.info

  - 这个文件用于保存备库连接到主库所需要的信息，格式为纯文本（每行一个值），不同的MySQL版本，其记录的信息也可能不同。
  - 此文件不能删除，否则备库在重启后无法连接到主库。这个文件以文本的方式记录了复制用户的密码，所以要注意此文件的权限控制。


- relay-log.info
  - 这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如，备库复制在主库上的位置），同样也不要删除这个文件，否则在备库重启后将无法获知从哪个位置开始复制，可能会导致重放已经执行过的语句。

#### 10.3.5　发送复制事件到其他备库

- log_slave_updates选项可以让备库变成其他服务器的主库。在设置该选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中。这样它的备库就可以从其日志中检索并执行事件。
	- 在这种场景下，主库将数据更新事件写入二进制日志，第一个备库提取并执行这个事件。这时候一个事件的生命周期应该已经结束了，但由于设置了log_slave_updates，备库会将这个事件写到它自己的二进制日志中。这样第二个备库就可以将事件提取到它的中继日志中并执行。这意味着作为源服务器的主库可以将其数据变化传递给没有与其直接相连的备库上。默认情况下这个选项是被打开的，这样在连接到备库时就不需要重启服务器。

#### 10.3.6　复制过滤器

- 有两种复制过滤方式：在主库上过滤记录到二进制日志中的事件，以及在备库上过滤记录到中继日志的事件。
- 假如要阻止赋权限操作传递给备库，这种需求是很普遍的。
- 过滤系统表的复制当然能够阻止GRANT语句的复制，但同样也会阻止事件和定时任务的复制。正是这些不可预知的后果，使用复制过滤要非常慎重。
- 更好的办法是阻止一些特殊的语句被复制，通常是设置SQL_LOG_BIN=0，虽然这种方法也有它的缺点。总地来说，除非万不得已，不要使用复制过滤，因为它很容易中断复制并导致问题，在需要灾难恢复时也会带来极大的不方便。

### 10.4　复制拓扑

- 可以在任意个主库和备库之间建立复制，只有一个限制：每一个备库只能有一个主库。
- 基本原则：

  - 一个MySQL备库实例只能有一个主库。
  - 每个备库必须有一个唯一的服务器ID。
  - 一个主库可以有多个备库（或者相应的，一个备库可以有多个兄弟备库）。
  - 如果打开了log_slave_updates选项，一个备库可以把其主库上的数据变化传播到其他备库。


#### 10.4.1　一主库多备库

- 它的一些用途：

  - 为不同的角色使用不同的备库（例如添加不同的索引或使用不同的存储引擎）。
  - 把一台备库当作待用的主库，除了复制没有其他数据传输。
  - 将一台备库放到远程数据中心，用作灾难恢复。
  - 延迟一个或多个备库，以备灾难恢复。
  - 使用其中一个备库，作为备份、培训、开发或者测试使用服务器。

#### 10.4.2　主动-主动模式下的主-主复制

- 主-主复制（也叫双主复制或双向复制）包含两台服务器，每一个都被配置成对方的主库和备库，换句话说，它们是一对主库。
- 主动-主动模式下主-主复制有一些应用场景，但通常用于特殊的目的。一个可能的应用场景是两个处于不同地理位置的办公室，并且都需要一份可写的数据拷贝。
- 这种配置最大的问题是如何解决冲突，两个可写的互主服务器导致的问题非常多。这通常发生在两台服务器同时修改一行记录，或同时在两台服务器上向一个包含AUTO_INCREMENT列的表里插入数据(8)。
- MySQL 5.0增加了一些特性，使得这种配置稍微安全了点，就是设置auto_increment_increment和auto_increment_offset。通过这两个选项可以让MySQL自动为INSERT语句选择不互相冲突的值。

#### 10.4.3　主动-被动模式下的主-主复制

- 这种方式使得反复切换主动和被动服务器非常方便，因为服务器的配置是对称的。这使得故障转移和故障恢复很容易。它也可以让你在不关闭服务器的情况下执行维护、优化表、升级操作系统（或者应用程序、硬件等）或其他任务。
- 让我们看看如何配置主-主服务器对，在两台服务器上执行如下设置后，会使其拥有对称的设置：

  - 确保两台服务器上有相同的数据。
  - 启用二进制日志，选择唯一的服务器ID，并创建复制账号。
  - 启用备库更新的日志记录，后面将会看到，这是故障转移和故障恢复的关键。
  - 把被动服务器配置成只读，防止可能与主动服务器上的更新产生冲突，这一点是可选的。
  - 启动每个服务器的MySQL实例。
  - 将每个主库设置为对方的备库，使用新创建的二进制日志开始工作。

- 设置主动-被动的主-主拓扑结构在某种意义上类似于创建一个热备份，但是可以使用这个“备份”来提高性能

#### 10.4.4　拥有备库的主-主结构

#### 10.4.5　环形复制

- 环形结构没有双主结构的一些优点，例如对称配置和简单的故障转移，并且完全依赖于环上的每一个可用节点，这大大增加了整个系统失效的几率。
- 如果从环中移除一个节点，这个节点发起的事件就会陷入无限循环：它们将永远绕着服务器链循环。因为唯一可以根据服务器ID将其过滤的服务器是创建这个事件的服务器。总地来说，环形结构非常脆弱，应该尽量避免。
- 可以通过为每个节点增加备库的方式来减少环形复制的风险，

#### 10.4.6　主库、分发主库以及备库

- 如果需要多个备库，一个好办法是从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。
- 多个备库连接到分发主库，这使原来的主库摆脱了负担。为了避免在分发主库上做实际的查询，可以将它的表修改为blackhole存储引擎
- 如果在分发主库上使用blackhole表，可以支持更多的备库。虽然会在分发主库执行查询，但其代价非常小，因为blackhole表中没有任何数据。
- 使用分发主库另外一个主要的缺点是无法使用一个备库来代替主库。因为由于分发主库的存在，导致各个备库与原始主库的二进制日志坐标已经不相同

#### 10.4.7　树或金字塔形

- 这种设计的好处是减轻了主库的负担，就像前一节提到的分发主库一样。它的缺点是中间层出现的任何错误都会影响到多个服务器。

#### 10.4.8　定制的复制方案

- 选择性复制

  - 最简单的方法是在主库上将数据划分到不同的数据库里。然后将每个数据库复制到不同的备库上。
  - 如果想通过一个很慢或者非常昂贵的网络，从一台负载很高的数据库上复制一部分数据，就可以使用一个包含blackhole表和过滤规则的本地分发主库，分发主库可以通过复制过滤移除不需要的日志。这可以避免在主库上进行不安全的日志选项设定，并且无须传输所有的数据到远程备库。

- 分离功能

  - OLTP查询比较短并且是事务型的，OLAP查询则通常很大，也很慢，并且不要求绝对最新的数据。这两种查询给服务器带来的负担完全不同，因此它们需要不同的配置，甚至可能使用不同的存储引擎或者硬件。
  - 一个常见的办法是将OLTP服务器的数据复制到专门为OLAP工作负载准备的备库上。这些备库可以有不同的硬件、配置、索引或者不同的存储引擎。
  - 无须做一些特殊的配置，除了需要选择忽略主库上的一些数据，前提是能获得明显的提升。即使通过复制过滤器过滤掉一小部分的数据也会减少I/O和缓存活动

- 数据归档

  - 可以在备库上实现数据归档，也就是说可以在备库上保留主库上删除过的数据，在主库上通过delete语句删除数据是确保delete语句不传递到备库就可以实现。
  - 有两种通常的办法：一种是在主库上选择性地禁止二进制日志，另一种是在备库上使用replicate_ignore_db规则
  - 第一种方法需要先将SQL_LOG_BIN设置为0，然后再进行数据清理。这种方法的好处是不需要在备库进行任何配置，由于SQL语句根本没有记录到二进制日志中，效率会稍微有所提升。最大缺点也正因为没有将在主库的修改记录下来，因此无法使用二进制日志来进行审计或者做按时间点的数据恢复。另外还需要SUPER权限。
  - 第二种方法是在清理数据之前对主库上特定的数据库使用USE语句。例如，可以创建一个名为purge的数据库，然后在备库的my.cnf文件里设置replicate_ignore_db=purge并重启服务器。备库将会忽略使用了USE语句指定的数据库。这种方法没有第一种方法的缺点，但有另一个小小的缺点：备库需要去读取它不需要的事件。

- 将备库用作全文检索

  - 一个普遍的做法是配置一台备库，将某些表设置为MyISAM存储引擎，然后创建全文索引并执行全文检索查询。这避免了在主库上同时使用事务型和非事务型存储引擎所带来的复制问题，减轻了主库维护全文索引的负担。

- 只读备库

  - 许多机构选择将备库设置为只读，以防止在备库进行的无意识修改导致复制中断。可以通过设置read_only选项来实现。它会禁止大部分写操作，除了复制线程和拥有超级权限的用户以及临时表操作。只要不给也不应该给普通用户超级权限，这应该是很完美的方法。

- 模拟多主库复制
- 创建日志服务器

  - 使用MySQL复制的另一种用途就是创建没有数据的日志服务器。它唯一的目的就是更加容易重放并且/或者过滤二进制日志事件。
  - 日志放到日志服务器的日志文件夹中，假设为`/var/log/mysql`。然后在启动服务器前编辑my.cnf文件，如下所示：`log_bin = /var/log/mysql/somelog-bin log_bin_index = /var/log/mysql/somelog-bin.index`
  - 为什么使用日志服务器比用mysqlbinlog来实现恢复更好呢？有以下几个原因：

    - 复制作为应用二进制日志的方法已经被大量的用户所测试，能够证明是可行的。mysqlbinlog并不能确保像复制那样工作，并且可能无法正确生成二进制日志中的数据更新。
    - 复制的速度更快，因为无须将语句从日志导出来并传送给MySQL。
    - 可以很容易观察到复制过程。
    - 能够更方便处理错误。例如，可以跳过执行失败的语句。
    - 更方便过滤复制事件。
    - 有时候mysqlbinlog会因为日志记录格式更改而无法读取二进制日志。

