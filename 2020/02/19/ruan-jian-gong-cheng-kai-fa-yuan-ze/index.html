<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="软件工程开发原则, 编程 读书 生活">
    <meta name="description" content="
❗: 这个仓库包含对一些定律、原则以及模式的解释，但不提倡其中任何一个。 它们的应用始终存在着争论，并且很大程度上取决于你正在做什么。
定律阿姆达尔定律 (Amdahl’s Law)
英文维基百科
中文维基百科


阿姆达尔定律是一个显示">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>软件工程开发原则 | Asxing-阿行</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Asxing-阿行" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Asxing-阿行</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Asxing-阿行</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/asxing" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/asxing" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://www.holddie.com/img/20200219222041.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        软件工程开发原则
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%8E%9F%E5%88%99/">
                                <span class="chip bg-color">原则</span>
                            </a>
                        
                            <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">
                                <span class="chip bg-color">软件开发</span>
                            </a>
                        
                            <a href="/tags/%E5%AE%9A%E5%BE%8B/">
                                <span class="chip bg-color">定律</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/" class="post-category">
                                软件开发
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-19
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    32 分
                </div>
                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><img src="https://www.holddie.com/img/20200219222041.png" alt=""></p>
<p>❗: 这个仓库包含对一些定律、原则以及模式的解释，但不<strong>提倡</strong>其中任何一个。 它们的应用始终存在着争论，并且很大程度上取决于你正在做什么。</p>
<h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h2><h3 id="阿姆达尔定律-Amdahl’s-Law"><a href="#阿姆达尔定律-Amdahl’s-Law" class="headerlink" title="阿姆达尔定律 (Amdahl’s Law)"></a>阿姆达尔定律 (Amdahl’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Amdahl' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/阿姆达尔定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>阿姆达尔定律是一个显示计算任务<strong>潜在加速</strong>能力的公式。这种能力可以通过增加系统资源来实现，通常用于并行计算中。它可以预测增加处理器数量的实际好处，然而增加处理器数量会受到程序并行性的限制。</p>
</blockquote>
<p>举例说明：如果程序由两部分组成，部分 A 必须由单个处理器执行，部分 B 可以并行运行。那么向执行程序的系统添加多个处理器只能获得有限的好处。它可以极大地提升部分 B 的运行速度，但部分 A 的运行速度将保持不变。</p>
<p>下图展示了一些运行速度的提升潜能的例子：</p>
<p><img src="https://www.holddie.com/img/20200219220922.png" alt="阿姆达尔定律"></p>
<p><em>(图片来源: By Daniels220 at English Wikipedia, Creative Commons Attribution-Share Alike 3.0 Unported, <a href="https://en.wikipedia.org/wiki/File:AmdahlsLaw.svg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/File:AmdahlsLaw.svg</a>)</em></p>
<p>可以看出，50％ 并行化的程序在使用大于 10 个处理单元之后的速度提升收效甚微，而 95％ 并行化的程序在使用超过一千个处理单元之后仍然可以显著提升速度。</p>
<p>随着<a href="https://github.com/nusr/hacker-laws-zh#摩尔定律-moores-law" target="_blank" rel="noopener">摩尔定律</a>减慢，单个处理器的速度增加缓慢，并行化是提高性能的关键。图形编程是一个极好的例子，现代着色器可以并行渲染单个像素或片段。这也是现代显卡通常具有数千个处理核心（GPU 或着色器单元）的原因。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#布鲁克斯法则-brookss-law" target="_blank" rel="noopener">布鲁克斯法则</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#摩尔定律-moores-law" target="_blank" rel="noopener">摩尔定律</a></li>
</ul>
<h3 id="破窗效应-The-Broken-Windows-Theory"><a href="#破窗效应-The-Broken-Windows-Theory" class="headerlink" title="破窗效应 (The Broken Windows Theory)"></a>破窗效应 (The Broken Windows Theory)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Broken_windows_theory" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/破窗效应" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<p>在破窗理论中认为，一些明显的犯罪迹象(或缺乏环保意识)会导致进一步的、更严重的犯罪(或环境的进一步恶化)。</p>
<p>破窗理论已应用于软件开发中，它表明劣质代码(或 <a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Technical Debt</a>)可能会影响后续优化的效率，从而进一步造成代码劣化；随着时间的推移，这种效应将会导致代码质量大幅下降。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Technical Debt</a></li>
</ul>
<p>例子：</p>
<ul>
<li><a href="https://pragprog.com/the-pragmatic-programmer/extracts/software-entropy" target="_blank" rel="noopener">《程序员修炼之道：软件熵》(The Pragmatic Programming: Software Entropy)</a></li>
<li><a href="https://blog.codinghorror.com/the-broken-window-theory/" target="_blank" rel="noopener">《Coding Horror：破窗效应》(Coding Horror: The Broken Window Theory)</a></li>
<li><a href="https://opensourceforu.com/2011/05/joy-of-programming-broken-window-theory/" target="_blank" rel="noopener">《开源：编程之乐 - 破窗效应》(OpenSource: Joy of Programming - The Broken Window Theory)</a></li>
</ul>
<h3 id="布鲁克斯法则-Brooks’s-Law"><a href="#布鲁克斯法则-Brooks’s-Law" class="headerlink" title="布鲁克斯法则 (Brooks’s Law)"></a>布鲁克斯法则 (Brooks’s Law)</h3><ul>
<li><a href="https://en.m.wikipedia.org/wiki/Brooks' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
</ul>
<blockquote>
<p>软件开发后期，添加人力只会使项目开发得更慢。</p>
</blockquote>
<p>这个定律表明，在许多情况下，试图通过增加人力来加速已延期项目的交付，将会使项目交付得更晚。布鲁克斯也明白，这是一种过度简化。但一般的论据是，新资源的时间增加和通信开销，会在短期内使开发速度减慢。而且，许多任务是密不可分的，换句话说，这样可以使更多的资源之间能轻易分配，这也意味着潜在的速度增长也更低。</p>
<p>谚语 <strong>九个女人不能在一个月内生一个孩子</strong> 与布鲁克斯法则同出一辙，特别是某些不可分割或者并行的工作。</p>
<p>这是<a href="https://github.com/nusr/hacker-laws-zh#阅读清单" target="_blank" rel="noopener">《人月神话》</a>的中心主题。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Death March</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#阅读清单" target="_blank" rel="noopener">阅读清单：《人月神话》</a></li>
</ul>
<h3 id="康威定律-Conway’s-Law"><a href="#康威定律-Conway’s-Law" class="headerlink" title="康威定律 (Conway’s Law)"></a>康威定律 (Conway’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Conway' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/康威定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<p>这个定律说明了系统的技术边界可以反应一个组织的结构，它通常会在改进组织时被提及。康威定律表明，如果一个组织被分散成许多小而无联系的单元，那么它开发的软件也是小而分散的。如果组织是更多地围绕以功能或服务为导向的<strong>垂直</strong>结构，那么软件系统也会反映这一点。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#spotify-模型-the-spotify-model" target="_blank" rel="noopener">The Spotify Model</a></li>
</ul>
<h3 id="坎宁汉姆定律-Cunningham’s-Law"><a href="#坎宁汉姆定律-Cunningham’s-Law" class="headerlink" title="坎宁汉姆定律 (Cunningham’s Law)"></a>坎宁汉姆定律 (Cunningham’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Ward_Cunningham#Cunningham' target="_blank" rel="noopener"s_Law">英文维基百科</a></li>
</ul>
<blockquote>
<p>在网络上想得到正确答案的最好方法不是提问题，而是发布一个错误的答案。</p>
</blockquote>
<p>据史蒂芬·麦克基迪说，沃德·坎宁汉姆早在 20 世纪 80 年代早期的时候建议他，在互联网上获得正确答案的最好方法不是提问题，而是发布一个错误的答案。麦克基迪称这为坎宁汉姆定律，而坎宁汉姆不以为然，并觉得这是“错误的引用”。最初这条定律只是用于描述 Usenet 上的社交行为，但后来也渐渐用于其他的在线社区（如 Wikipedia、Reddit、Twitter、Facebook 等）。</p>
<p>参见：</p>
<ul>
<li><a href="https://xkcd.com/386/" target="_blank" rel="noopener">XKCD 386: “Duty Calls”</a></li>
</ul>
<h3 id="邓巴数字-Dunbar’s-Number"><a href="#邓巴数字-Dunbar’s-Number" class="headerlink" title="邓巴数字 (Dunbar’s Number)"></a>邓巴数字 (Dunbar’s Number)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Dunbar' target="_blank" rel="noopener"s_number">英文维基百科</a></li>
</ul>
<p>邓巴数字是对一个人能够保持稳定社会关系的人数的认知极限——在这种关系中，一个人知道每个人是谁，也知道每个人与其他人的关系如何。而对这一数字的确切值则有着一些不同意见。邓巴指出，人仅能轻松地维持 150 个稳定的关系。这样的关系在一个更社会化的背景中，便是当你碰巧在酒吧里碰到这些人时候，你不会因为加入他们而感到尴尬。邓巴数字的估计值一般在 100 至 250 之间。</p>
<p>和人与人之间稳定的关系一样，开发人员与代码库的关系也需要努力维护。当面对大型、复杂的项目，或许多项目的归属权时，我们会依赖于约定、策略和建模过程来进行扩展。邓巴数字不仅在办公室规模的扩大的过程中举足轻重，而且在设置团队工作范围，或决定系统何时应该注重于辅助建模和组织管理开销自动化的工具时，也是非常重要的。将邓巴数字放入工程内容中进行类比，那就是您能加入并有信心随叫随到进行轮换的项目数(亦或是单个项目的规范化复杂性)。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#康威定律-conways-law" target="_blank" rel="noopener">康威定律</a></li>
</ul>
<h3 id="盖尔定律-Gall’s-Law"><a href="#盖尔定律-Gall’s-Law" class="headerlink" title="盖尔定律 (Gall’s Law)"></a>盖尔定律 (Gall’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/John_Gall_(author)#Gall' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
</ul>
<blockquote>
<p>一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。</p>
<p><a href="https://en.wikipedia.org/wiki/John_Gall_(author)" target="_blank" rel="noopener">约翰·盖尔</a> (John Gall)</p>
</blockquote>
<p>盖尔定律说明了设计高度复杂的系统很可能会失败。它们很难一蹴而就，更多是从简单的系统逐渐演变而来。</p>
<p>最典型的例子便是互联网。如今的互联网是一个高度复杂的系统，而它最早只是被定义为一种在学术机构之间共享内容的方式。互联网成功实现了最初的目标，并且随着时间不断演化，最终成就了如今的复杂繁荣。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#kiss-原则-the-kiss-principle" target="_blank" rel="noopener">KISS 原则 (保持简单和直白)</a></li>
</ul>
<h3 id="古德哈特定律-Goodhart’s-Law"><a href="#古德哈特定律-Goodhart’s-Law" class="headerlink" title="古德哈特定律 (Goodhart’s Law)"></a>古德哈特定律 (Goodhart’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Goodhart' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/古德哈特定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>当压力施于其上以进行控制时，任何观测到的统计恒性都倾向消散。</p>
<p><em>查尔斯·古德哈特 (Charles Goodhart)</em></p>
</blockquote>
<p>另见：</p>
<blockquote>
<p>当一个措施本身成为目标时，它就不再是一个好的措施。</p>
<p><em>玛丽莲·斯特拉腾 (Marilyn Strathern)</em></p>
</blockquote>
<p>根据这一定律，由测量驱动的优化反而可能导致测量结果本身的说服力下降。盲目使用一些过度严格筛选的方法 (<a href="https://zh.wikipedia.org/wiki/關鍵績效指標" target="_blank" rel="noopener">KPIs</a>) 可能会产生一些不良的影响。人们会倾向于用“钻空子”的行为去做局部优化，从而满足一些特定的度量标准，而不会在意整体的结果。</p>
<p>现实中的例子：</p>
<ul>
<li>Assert-free 测试可以达到代码覆盖率的预期，但度量的目的应该是创造经过良好测试的软件。</li>
<li>由 commits 的行数来评价开发人员的表现，从而导致了不合理的代码库扩增。</li>
</ul>
<p>参见</p>
<ul>
<li><a href="https://coffeeandjunk.com/goodharts-campbells-law/" target="_blank" rel="noopener">古德哈特定律：错误的测量如何导致不道德的行为</a></li>
<li><a href="https://dilbert.com/strip/1995-11-13" target="_blank" rel="noopener">呆伯特与无 bug 软件</a></li>
</ul>
<h3 id="汉隆的剃刀-Hanlon’s-Razor"><a href="#汉隆的剃刀-Hanlon’s-Razor" class="headerlink" title="汉隆的剃刀 (Hanlon’s Razor)"></a>汉隆的剃刀 (Hanlon’s Razor)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Hanlon' target="_blank" rel="noopener"s_razor">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/汉隆的剃刀" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>能解释为愚蠢的，就不要解释为恶意的。</p>
<p><em>罗伯特·汉隆 (Robert J. Hanlon)</em></p>
</blockquote>
<p>这一原则表明，一个行为所产生的消极结果并不是恶意。相反，消极结果更有可能归咎于这些没有得到充分理解的行动或影响。</p>
<h3 id="侯世达定律-Hofstadter’s-Law"><a href="#侯世达定律-Hofstadter’s-Law" class="headerlink" title="侯世达定律 (Hofstadter’s Law)"></a>侯世达定律 (Hofstadter’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Hofstadter' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/侯世达定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>即使考虑到侯世达定律，它也总是比你预期的要长。</p>
<p>侯世达 (Douglas Hofstadter)</p>
</blockquote>
<p>在估计需要多长时间开发时，你可能会听到此定律。软件开发似乎有这样一条定理，即我们往往不能准确地估计需要多长时间才能完成。</p>
<p>语出<a href="https://github.com/nusr/hacker-laws-zh#阅读清单" target="_blank" rel="noopener">《哥德尔、艾舍尔、巴赫：集异璧之大成》</a>。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#阅读清单" target="_blank" rel="noopener">阅读清单：《哥德尔、艾舍尔、巴赫：集异璧之大成》</a></li>
</ul>
<h3 id="哈伯特定律-Hutber’s-Law"><a href="#哈伯特定律-Hutber’s-Law" class="headerlink" title="哈伯特定律 (Hutber’s Law)"></a>哈伯特定律 (Hutber’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Hutber' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
</ul>
<blockquote>
<p>改善即恶化。</p>
<p><a href="https://en.wikipedia.org/wiki/Patrick_Hutber" target="_blank" rel="noopener">帕特里克·哈伯特</a> (Patrick Hutber)</p>
</blockquote>
<p>这个定律说明了对一个系统的改进会导致其他部分的恶化；或者它会将其他的恶化隐藏起来，并导致系统整体状态的退化。</p>
<p>例如，某个端点的响应延迟减少，就可能导致请求流中的吞吐量和容量问题进一步增加，并影响到另一个完全不同的子系统。</p>
<h3 id="技术成熟度曲线-The-Hype-Cycle-or-Amara’s-Law"><a href="#技术成熟度曲线-The-Hype-Cycle-or-Amara’s-Law" class="headerlink" title="技术成熟度曲线 (The Hype Cycle or Amara’s Law)"></a>技术成熟度曲线 (The Hype Cycle or Amara’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Hype_cycle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/技术成熟度曲线" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>我们倾向于过高估计技术在短期内的影响，并低估长期效应。</p>
<p><em>罗伊·阿马拉 (Roy Amara)</em></p>
</blockquote>
<p>技术成熟度曲线是<a href="https://zh.wikipedia.org/wiki/高德纳咨询公司" target="_blank" rel="noopener">高德纳咨询公司</a>对技术最初兴起和发展的视觉展现。一图顶千言：</p>
<p><img src="https://www.holddie.com/img/20200219221121.png" alt="The Hype Cycle"></p>
<p><em>(图片来源: By Jeremykemp at English Wikipedia, CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=10547051" target="_blank" rel="noopener">https://commons.wikimedia.org/w/index.php?curid=10547051</a>)</em></p>
<p>简而言之，这个周期表明，新技术及其潜在影响通常会引发一阵浪潮。团队快速使用这些新技术，有时会对结果感到失望。这可能是因为该技术还不够成熟，或者现实应用还没有完全实现。经过一段时间后，技术的能力提高了，使用它的实际机会会增加，最终团队也可以提高工作效率。罗伊·阿马拉简洁地总结了这一点：我们倾向于高估技术短期内的影响，并低估长期效应。</p>
<h3 id="隐式接口定律-Hyrum’s-Law-or-The-Law-of-Implicit-Interfaces"><a href="#隐式接口定律-Hyrum’s-Law-or-The-Law-of-Implicit-Interfaces" class="headerlink" title="隐式接口定律 (Hyrum’s Law or The Law of Implicit Interfaces)"></a>隐式接口定律 (Hyrum’s Law or The Law of Implicit Interfaces)</h3><ul>
<li><a href="http://www.hyrumslaw.com/" target="_blank" rel="noopener">英文在线地址</a></li>
</ul>
<blockquote>
<p>当 API 有足够多的用户时，你在合同中的承诺已不重要：你系统的所有可观察行为都将被某些人所依赖。</p>
<p><em>海伦·赖特（Hyrum Wright）</em></p>
</blockquote>
<p>隐式接口定律表明，当你的 API 有足够多的用户时，API 的所有行为（包括那些未囊括在公共说明中的一部分）最终都会被其他人所依赖。 一个简单的例子是 API 的响应时间这种非功能性因素，还有一个更微妙的例子是：用户使用正则表达式判断错误信息的类型时，即使 API 的公共说明没有说明消息的内容，来指示用户错误的类型，一些用户也可能会使用并更改该消息，而这实际上会破坏 API 的使用。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#漏洞抽象定律-the-law-of-leaky-abstractions" target="_blank" rel="noopener">抽象泄漏定律</a></li>
<li><a href="https://xkcd.com/1172/" target="_blank" rel="noopener">XKCD 1172</a></li>
</ul>
<h3 id="梅特卡夫定律-Metcalfe’s-Law"><a href="#梅特卡夫定律-Metcalfe’s-Law" class="headerlink" title="梅特卡夫定律 (Metcalfe’s Law)"></a>梅特卡夫定律 (Metcalfe’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Metcalfe' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/梅特卡夫定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>在网络理论中，系统的价值约等于系统用户数的平方。</p>
</blockquote>
<p>这个定律基于一个系统中可能的连接对数量，并且与<a href="https://github.com/nusr/hacker-laws-zh#里德定律-reeds-law" target="_blank" rel="noopener">里德定律</a>十分相近。奥德利兹科 (Odlyzko) 和其他人认为，里德定律和梅特卡夫定律夸大了系统本身的价值，因为它们没有考虑到网络效应中人类认知的限制。</p>
<p>参见:</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#里德定律-reeds-law" target="_blank" rel="noopener">里德定律</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#邓巴数字-dunbars-number" target="_blank" rel="noopener">邓巴数字</a></li>
</ul>
<h3 id="摩尔定律-Moore’s-Law"><a href="#摩尔定律-Moore’s-Law" class="headerlink" title="摩尔定律 (Moore’s Law)"></a>摩尔定律 (Moore’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Moore' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/摩尔定律" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>集成电路中的晶体管数量大约每两年翻一番。</p>
</blockquote>
<p>这条定律通常用于说明半导体和芯片技术提高的绝对速度。从 20 世纪 70 年代到 21 世纪前十年，摩尔的预测被证明是高度准确的。 近年来，这种趋势略有变化，部分原因受到<a href="https://zh.wikipedia.org/wiki/量子穿隧效應" target="_blank" rel="noopener">量子隧穿效应</a>影响。然而，并行化计算的进步以及半导体技术和量子计算潜在的革命性变化，可能意味着摩尔定律在未来几十年内继续保持正确。</p>
<h3 id="墨菲定律-Murphy’s-Law-Sod’s-Law"><a href="#墨菲定律-Murphy’s-Law-Sod’s-Law" class="headerlink" title="墨菲定律 (Murphy’s Law / Sod’s Law)"></a>墨菲定律 (Murphy’s Law / Sod’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Murphy' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/摩菲定理" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>凡是可能出错的事就一定会出错。</p>
</blockquote>
<p>出自 <a href="https://en.wikipedia.org/wiki/Edward_A._Murphy_Jr." target="_blank" rel="noopener">爱德华·A·墨菲</a> ， <em>墨菲定律</em> 说明了如果一件事有可能出错，那么就一定会出错。</p>
<p>这是一句开发人员间的俗语，在开发、测试甚至在生产中都有可能会发生一些令人意想不到的事情。而这一定律也可以参考在英式英语中更为常见的 <em>索德定理</em> ：</p>
<blockquote>
<p>如果某件事可能出错，那么它一定会在最糟糕的时候发生。</p>
</blockquote>
<p>这些定律常常用于幽默嘲弄。但是，类似于 <a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener"><em>Confirmation Bias</em></a> 和 <a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener"><em>Selection Bias</em></a> 的现象很容易导致人们过分强调这些定律（即在大部分情况下，一件事的成功会显得司空见惯；而失败才会引起更多的注意和讨论）。</p>
<p>参见:</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Confirmation Bias</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Selection Bias</a></li>
</ul>
<h3 id="奥卡姆剃刀-Occam’s-Razor"><a href="#奥卡姆剃刀-Occam’s-Razor" class="headerlink" title="奥卡姆剃刀 (Occam’s Razor)"></a>奥卡姆剃刀 (Occam’s Razor)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Occam' target="_blank" rel="noopener"s_razor">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/奥卡姆剃刀" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>如无必要，勿增实体。</p>
<p>奥卡姆的威廉 (William of Ockham)</p>
</blockquote>
<p>奥卡姆剃刀指出，在几种可能的解决方案之中，最有可能的解决方案便是概念和假设最少的那个。因为这个解决方案最为简单，只解决了问题，并且没有引入额外的复杂度和可能的负面后果。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#你不需要它原则-yagni" target="_blank" rel="noopener">你不需要它原则 (YAGNI)</a></li>
<li><a href="https://zh.wikipedia.org/wiki/没有银弹" target="_blank" rel="noopener">没有银弹：软件工程的本质性与附属性工作</a></li>
<li><a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank" rel="noopener">No Silver Bullet: Accidental Complexity and Essential Complexity</a></li>
</ul>
<p>例子：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/精益软件开发#消除浪费" target="_blank" rel="noopener">精益软件开发：消除浪费</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lean_software_development#Eliminate_waste" target="_blank" rel="noopener">Lean Software Development: Eliminate Waste</a></li>
</ul>
<h3 id="帕金森定理-Parkinson’s-Law"><a href="#帕金森定理-Parkinson’s-Law" class="headerlink" title="帕金森定理 (Parkinson’s Law)"></a>帕金森定理 (Parkinson’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Parkinson' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/帕金森定理" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>在工作能够完成的时限内，工作量会一直增加，直到所有可用时间都被填满为止。</p>
</blockquote>
<p>基于官僚机构的研究背景，该定律被应用于软件开发中。该理论认为，团队在截止日期之前效率低下，然后在截止日期前赶紧完成工作，从而使实际截止日期变得随意。</p>
<p>将这个定理与<a href="https://github.com/nusr/hacker-laws-zh#侯世达定律-hofstadters-law" target="_blank" rel="noopener">侯世达定律</a>相结合，则会获得更加悲观的观点：为了在规定时间内完成工作，工作将增多，花费比预期更长的时间。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#侯世达定律-hofstadters-law" target="_blank" rel="noopener">侯世达定律</a></li>
</ul>
<h3 id="过早优化效应-Premature-Optimization-Effect"><a href="#过早优化效应-Premature-Optimization-Effect" class="headerlink" title="过早优化效应 (Premature Optimization Effect)"></a>过早优化效应 (Premature Optimization Effect)</h3><ul>
<li><a href="http://wiki.c2.com/?PrematureOptimization" target="_blank" rel="noopener">英文在线网站</a></li>
</ul>
<blockquote>
<p>过早优化是万恶之源。</p>
<p><a href="https://twitter.com/realdonaldknuth?lang=en" target="_blank" rel="noopener">高德纳 (唐纳德克努特的中文名)</a></p>
</blockquote>
<p>在高德纳的<a href="http://wiki.c2.com/?StructuredProgrammingWithGoToStatements" target="_blank" rel="noopener">《goto 语句的结构化编程》</a>论文中，他写到：“程序员们浪费了大量的时间去思考或者担心他们的程序中的非关键部分的速度。而在考虑调试和维护的时候，这些所谓提高效率的做法实际上十分不妥。我们应该放弃小的效率点，并且要在 97% 的时间提醒自己，<strong>过早优化是万恶之源</strong>。而且连那关键的 3% 也不能够放过。”</p>
<p>然而，<em>过早优化</em> （简而言之）可以定义为在我们知道需要做什么之前进行优化。</p>
<h3 id="普特定律-Putt’s-Law"><a href="#普特定律-Putt’s-Law" class="headerlink" title="普特定律 (Putt’s Law)"></a>普特定律 (Putt’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Putt' target="_blank" rel="noopener"s_Law_and_the_Successful_Technocrat">英文维基百科</a></li>
</ul>
<blockquote>
<p>技术由两类人主导，一类是纯粹的管理人员， 一类是纯粹的技术人员。</p>
</blockquote>
<p>普特定律常常遵循普特推论：</p>
<blockquote>
<p>每一个技术层次，假以时日，能力将逆转。</p>
</blockquote>
<p>这些结论表明，由于各种选择标准和群体组织的趋势，技术组织的工作层面将有一些技术人员，以及一些不了解复杂性和挑战的管理人员。这种现象可能是由于 <a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">The Peter Principe</a> 或 <a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Dilbert’s Law</a> 造成的。</p>
<p>但是，应该强调的是，诸如此类的定律是一种广泛的概括，可能适用于某些类型的组织，而不适用于其他组织。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">The Peter Principe</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#TODO" target="_blank" rel="noopener">Dilbert’s Law</a>.</li>
</ul>
<h3 id="里德定律-Reed’s-Law"><a href="#里德定律-Reed’s-Law" class="headerlink" title="里德定律 (Reed’s Law)"></a>里德定律 (Reed’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Reed' target="_blank" rel="noopener"s_law">英文维基百科</a></li>
</ul>
<blockquote>
<p>大型网络，尤其是社交网络的效用会随着网络的大小呈指数级扩增。</p>
</blockquote>
<p>这一定律基于图论，图论中的效用与可能的子组数量呈正比，并且该增长速度会比参与者的数量和可能的连接对数量要快。奥德利兹科 (Odlyzko) 和其他人认为，里德定律夸大了系统本身的价值，因为它们没有考虑到网络效应中人类认知的限制。</p>
<p>参见:</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#梅特卡夫定律-metcalfes-law" target="_blank" rel="noopener">梅特卡夫定律 (Metcalfe’s Law)</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#邓巴数字-dunbars-number" target="_blank" rel="noopener">邓巴数字</a></li>
</ul>
<h3 id="复杂性守恒定律-The-Law-of-Conservation-of-Complexity-or-Tesler’s-Law"><a href="#复杂性守恒定律-The-Law-of-Conservation-of-Complexity-or-Tesler’s-Law" class="headerlink" title="复杂性守恒定律 (The Law of Conservation of Complexity or Tesler’s Law)"></a>复杂性守恒定律 (The Law of Conservation of Complexity or Tesler’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Law_of_conservation_of_complexity" target="_blank" rel="noopener">英文维基百科</a></li>
</ul>
<p>该定律表明系统中存在着一定程度的复杂性，并且不能减少。</p>
<p>系统中的某些复杂性是<strong>无意的</strong>。这是由于结构不良，错误或者糟糕的建模造成的。这种无意的复杂性可以减少或者消除。然而，由于待解决问题固有的复杂性，某些复杂性是<strong>内在的</strong>。这种复杂性可以转移，但不能消除。</p>
<p>该定律有趣的一点是，即使简化整个系统，内在的复杂性也不会降低。它会<strong>转移到用户</strong>，并且用户必须以更复杂的方式行事。</p>
<h3 id="抽象泄漏定律-The-Law-of-Leaky-Abstractions"><a href="#抽象泄漏定律-The-Law-of-Leaky-Abstractions" class="headerlink" title="抽象泄漏定律 (The Law of Leaky Abstractions)"></a>抽象泄漏定律 (The Law of Leaky Abstractions)</h3><ul>
<li><a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" target="_blank" rel="noopener">英文在线地址</a></li>
</ul>
<blockquote>
<p>在某种程度上，所有非平凡的抽象都是有泄漏的。</p>
<p><a href="https://twitter.com/spolsky" target="_blank" rel="noopener">乔尔斯·波尔斯基</a> (Joel Spolsky)</p>
</blockquote>
<p>该定律指出，通常用于简化复杂系统的抽象，在某些情况下将底层系统泄漏出来，使得抽象表现出意外的行为。</p>
<p>例如加载文件并读取其内容。文件系统 API 是较低级别内核系统的抽象，它们本身是与磁盘（或 SSD 的闪存）上的数据更改相关的物理过程的抽象。在大多数情况下，处理文件（如二进制数据流）的抽象将起作用。但是，对于磁盘驱动器，顺序读取数据将比随机访问快得多（由于页面错误的开销增加）。但对于 SSD 驱动器，此开销不会出现。需要理解基础细节来处理这种情况（例如，数据库索引文件的良好结构可以减少随机访问的开销），开发人员需要合理的抽象，来处理不同的细节。</p>
<p>当引入更多的抽象时，上面的例子会变得更复杂。Linux 操作系统允许通过网络访问文件，但在本地表示为<strong>普通</strong>文件。如果存在网络故障，这种抽象将会<strong>泄漏</strong>。如果开发人员将这些文件视为<strong>普通</strong>文件，而不考虑它们可能会受到网络延迟和故障的影响，那么解决方案就会出错。</p>
<p>描述该定律的文章表明，过度依赖抽象，加上对底层过程的理解不足，实际上使得问题在某些情况下更加复杂。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#隐式接口定律-hyrums-law" target="_blank" rel="noopener">隐式接口定律</a></li>
</ul>
<p>真实的例子：</p>
<ul>
<li><a href="https://forums.adobe.com/thread/376152" target="_blank" rel="noopener">Photoshop 启动缓慢</a>：我过去遇到过一个问题，就是 Photoshop 启动缓慢，有时需要几分钟。问题好像是 Photoshop 启动时，会读取当前默认打印机的一些信息。但是，如果该打印机实际上是一台网络打印机，则可能需要很长的时间。将网络打印机与本地打印机当作同样的抽象，导致连接不良的情况下出现问题。</li>
</ul>
<h3 id="帕金森琐碎定理-The-Law-of-Triviality"><a href="#帕金森琐碎定理-The-Law-of-Triviality" class="headerlink" title="帕金森琐碎定理 (The Law of Triviality)"></a>帕金森琐碎定理 (The Law of Triviality)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Law_of_triviality" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/帕金森瑣碎定理" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<p>该定理显示，群体将给予更多的时间和注意力来处理琐碎的问题，而不是用来处理严肃而实质性的问题。</p>
<p>常见的虚构例子是委员会批准核电站的计划，他们大部分时间都在讨论自行车棚的结构，而不是电厂本身等更为重要的设计。如果没有大量的专业知识或者准备，很难给非常大的复杂主题讨论提供宝贵的意见。但是，人们希望看到更多意见。因此，他们倾向于将大量时间集中在很容易推敲，但不一定被看重的小细节上。</p>
<p>由上面的虚构例子产生了 <strong>Bike Shedding</strong> 的说法，以形容在琐碎细节上浪费时间这一行为。</p>
<h3 id="Unix-哲学-The-Unix-Philosophy"><a href="#Unix-哲学-The-Unix-Philosophy" class="headerlink" title="Unix 哲学 (The Unix Philosophy)"></a>Unix 哲学 (The Unix Philosophy)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Unix哲学" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<p>Unix 哲学指软件组件应该很小，并专注于做一件特定的事情。将小而简单以及定义良好的单元组合在一起，而不是使用大而复杂的多用途程序，可以更轻松地构建系统。</p>
<p>像<strong>微服务架构</strong>这种现代实践可以认为是这种哲学的应用，其中服务很小，集中于做一件特定的事情，由简单的构建块组成复杂的行为。</p>
<h3 id="Spotify-模型-The-Spotify-Model"><a href="#Spotify-模型-The-Spotify-Model" class="headerlink" title="Spotify 模型 (The Spotify Model)"></a>Spotify 模型 (The Spotify Model)</h3><ul>
<li><a href="https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/" target="_blank" rel="noopener">英文在线地址</a></li>
</ul>
<p>Spotify 模型是团队和组织结构的一种方法，已被 Spotify 实验室推广开来。在此模型中，团队围绕功能而非技术进行组织。</p>
<p>Spotify 模型还普及了部落、行会以及章节的概念，这些是组织结构的其他组成部分。</p>
<h3 id="沃德勒定律-Wadler’s-Law"><a href="#沃德勒定律-Wadler’s-Law" class="headerlink" title="沃德勒定律 (Wadler’s Law)"></a>沃德勒定律 (Wadler’s Law)</h3><ul>
<li><a href="https://wiki.haskell.org/Wadler' target="_blank" rel="noopener"s_Law">英文在线地址</a></li>
</ul>
<blockquote>
<p>任何语言设计中，讨论下面列表中某个要素所花费的总时间与其位置成正比。</p>
<ol>
<li>语义 (Semantics)</li>
<li>语法 (Syntax)</li>
<li>词法 (Lexical syntax)</li>
<li>注释语法 (Lexical syntax of comments)</li>
</ol>
<p>（简而言之，在语义上花费一个小时，就要在注释语法上花费八个小时）。</p>
</blockquote>
<p>与 <a href="https://github.com/nusr/hacker-laws-zh#帕金森琐碎定理-the-law-of-triviality" target="_blank" rel="noopener">帕金森琐碎定理</a> 类似, 沃德勒定律指出，在设计语言时，与这些特征的重要性相比，花在语言结构上的时间过多。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#帕金森琐碎定理-the-law-of-triviality" target="_blank" rel="noopener">帕金森琐碎定理</a></li>
</ul>
<h3 id="惠顿定律-Wheaton’s-Law"><a href="#惠顿定律-Wheaton’s-Law" class="headerlink" title="惠顿定律 (Wheaton’s Law)"></a>惠顿定律 (Wheaton’s Law)</h3><ul>
<li><a href="http://www.wheatonslaw.com/" target="_blank" rel="noopener">网站链接</a></li>
<li><a href="https://dontbeadickday.com/" target="_blank" rel="noopener">官方节日</a></li>
</ul>
<blockquote>
<p>不要像个傻子一样。</p>
<p><em>威尔·惠顿 (Wil Wheaton)</em></p>
</blockquote>
<p>这条定律由威尔 · 惠顿（曾出演过星际迷航：下一代、生活大爆炸）创造，这个简洁而有力的定律旨在专业组织内营造和谐和尊重的环境。它可以在与同事交谈、代码审查、反驳观点和批评的时候派上用场。而且通常情况下，人们之间的专业交互也同样适用。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>原则通常是与设计相关的准则。</p>
<h3 id="呆伯特法则-The-Dilbert-Principle"><a href="#呆伯特法则-The-Dilbert-Principle" class="headerlink" title="呆伯特法则 (The Dilbert Principle)"></a>呆伯特法则 (The Dilbert Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Dilbert_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/呆伯特法則" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>公司会倾向于系统地将工作能力差的员工提升到管理层，以使他们脱离工作流程。</p>
<p><em>史考特·亚当斯 (Scott Adams)</em></p>
</blockquote>
<p>呆伯特原则是由史考特·亚当斯 (Dilbert 漫画连环画的创建者) 开发的一个管理概念，灵感来源于<a href="https://github.com/nusr/hacker-laws-zh#彼得原理-the-peter-principle" target="_blank" rel="noopener">彼得原理</a>。根据呆伯特原则，工作能力差的员工会被提升到管理层，从而限制他们所能造成的损害。亚当斯首先在 1995 年《华尔街日报》的一篇文章中解释了这一原则，随后在他 1996 年的商业书籍《呆伯特原则》中进行了扩展。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#the-peter-principle" target="_blank" rel="noopener">The Peter Principle</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#普特定律-putts-law" target="_blank" rel="noopener">普特定律</a></li>
</ul>
<h3 id="帕累托法则-The-Pareto-Principle-or-The-80-20-Rule"><a href="#帕累托法则-The-Pareto-Principle-or-The-80-20-Rule" class="headerlink" title="帕累托法则 (The Pareto Principle or The 80/20 Rule)"></a>帕累托法则 (The Pareto Principle or The 80/20 Rule)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Pareto_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/帕累托法则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>生活中大多数事情不是均匀分布的。</p>
</blockquote>
<p>帕累托法则可以帮你认识到大多数结果来自少数投入：</p>
<ul>
<li>某个软件的 80％ 代码只占了总分配时间的 20％（相反，最难的 20％ 代码部分占用了 80％ 的时间）</li>
<li>20％ 的努力产生了 80％ 的结果</li>
<li>20％ 的工作创造了 80％ 的收入</li>
<li>20％ 的错误导致了 80％ 的崩溃</li>
<li>20％ 的功能导致了 80％ 的使用量</li>
</ul>
<p>在 20 世纪 40 年代，公认为质量控制之父的美国罗马尼亚工程师约瑟夫·朱兰博士，<a href="https://en.wikipedia.org/wiki/Joseph_M._Juran" target="_blank" rel="noopener">开始将帕累托法则应用于质量问题</a>。</p>
<p>这个原则也被称为<strong>二八法则</strong>，<strong>重要的少数法则</strong>和<strong>因素稀疏原则</strong>。</p>
<p>现实的例子：</p>
<ul>
<li>微软 2002 年的报告表明，修复最常出现的 20％ 错误，将消除 Windows 和 Office 中 80％ 的 错误和崩溃。<a href="https://www.crn.com/news/security/18821726/microsofts-ceo-80-20-rule-applies-to-bugs-not-just-features.htm" target="_blank" rel="noopener">报告地址</a></li>
</ul>
<h3 id="彼得原理-The-Peter-Principle"><a href="#彼得原理-The-Peter-Principle" class="headerlink" title="彼得原理 (The Peter Principle)"></a>彼得原理 (The Peter Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Peter_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/彼得原理" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>在等级制度中，人往往会被提升到他们的“无法胜任的水平”。</p>
<p><em>劳伦斯·彼得 (Laurence J. Peter)</em></p>
</blockquote>
<p>这是由劳伦斯·彼得提出的一个管理概念。彼得原理认为，擅长工作的人会得到提升，直到他们达到不再成功的水平 (即他们所“无法胜任的水平”)。基于此，由于他们资历更高，被公司开除的可能性较小 (除非他们表现非常糟糕)。而且他们将继续担任几乎没有本职技能的职位，即使那些原本让他们成功的能力在新工作中并无必要。</p>
<p>有的工程师对此特别感兴趣，它们最初从事的是深度的技术工作，但走上了<strong>管理</strong>其他工程师的职业道路——这意味着需要一个完全不同的技能树。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#呆伯特法则" target="_blank" rel="noopener">呆伯特法则</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#普特定律-putts-law" target="_blank" rel="noopener">普特定律</a></li>
</ul>
<h3 id="鲁棒性原则-The-Robustness-Principle-or-Postel’s-Law"><a href="#鲁棒性原则-The-Robustness-Principle-or-Postel’s-Law" class="headerlink" title="鲁棒性原则 (The Robustness Principle or Postel’s Law)"></a>鲁棒性原则 (The Robustness Principle or Postel’s Law)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">英文维基百科</a></li>
</ul>
<blockquote>
<p>在自己所做的事情上要保守, 在接受别人的事情上要自由。</p>
</blockquote>
<p>通常应用于服务器应用程序开发中，该原则指出，你发送给其他人的内容应尽可能最小且符合要求，并且处理不符合要求的输入。</p>
<p>该原则的目标是构建稳健的系统。如果可以理解意图，它们可以处理不良的输入。但是，接受错误格式的输入可能存在安全隐患，特别是此类的输入未经过充分测试。</p>
<h3 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h3><p>这是一个缩写，指的是：</p>
<ul>
<li>S：<a href="https://github.com/nusr/hacker-laws-zh#单一功能原则-the-single-responsibility-principle" target="_blank" rel="noopener">单一功能原则 (The Single Responsibility Principle)</a></li>
<li>O：<a href="https://github.com/nusr/hacker-laws-zh#开闭原则-the-openclosed-principle" target="_blank" rel="noopener">开闭原则 (The Open/Closed Principle)</a></li>
<li>L：<a href="https://github.com/nusr/hacker-laws-zh#里氏替换原则-the-liskov-substitution-principle" target="_blank" rel="noopener">里氏替换原则 (The Liskov Substitution Principle)</a></li>
<li>I：<a href="https://github.com/nusr/hacker-laws-zh#接口隔离原则-the-interface-segregation-principle" target="_blank" rel="noopener">接口隔离原则 (The Interface Segregation Principle)</a></li>
<li>D：<a href="https://github.com/nusr/hacker-laws-zh#依赖反转原则-the-dependency-inversion-principle" target="_blank" rel="noopener">依赖反转原则 (The Dependency Inversion Principle)</a></li>
</ul>
<p>这些是 <a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Oriented Programming</a> 的关键原则。诸如此类的设计原则能够帮助开发人员构建更易于维护的系统。</p>
<h3 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 (The Single Responsibility Principle)"></a>单一功能原则 (The Single Responsibility Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/单一功能原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>每个模块或者类只应该有一项功能。</p>
</blockquote>
<p><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a> 的第一个原则。这个原则表明模块或者类只应该做一件事。实际上，这意味着对程序功能的单个小更改，应该只需要更改一个组件。例如，更改密码验证复杂性的方式应该只需要更改程序的一部分。</p>
<p>理论上讲，这使代码更健壮，更容易更改。知道正在更改的组件只有一个功能，这意味着测试更改更容易。使用前面的例子，更改密码复杂性组件应该只影响与密码复杂性相关的功能。变更具有许多功能的组件可能要困难得多。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Orientated Programming</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a></li>
</ul>
<h3 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 (The Open/Closed Principle)"></a>开闭原则 (The Open/Closed Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Open–closed_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/开闭原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>实体应开放扩展并关闭修改。</p>
</blockquote>
<p><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a> 的第二个原则。这个原则指出实体（可以是类、模块、函数等）应该能够使它们的行为易于扩展，但是它们的扩展行为不应该被修改。</p>
<p>举一个假设的例子，想象一个能够将 Markdown 转换为 HTML 的模块。如果可以扩展模块，而不修改内部模块来处理新的 markdown 特征，而无需修改内部模块，则可以认为是开放扩展。如果用户不能修改处理现有 Markdown 特征的模块，那么它被认为是关闭修改。</p>
<p>这个原则与面向对象编程紧密相关，让我们可以设计对象以便于扩展，但是可以避免以意想不到的方式改变其现有对象的行为。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Orientated Programming</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a></li>
</ul>
<h3 id="里氏替换原则-The-Liskov-Substitution-Principle"><a href="#里氏替换原则-The-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 (The Liskov Substitution Principle)"></a>里氏替换原则 (The Liskov Substitution Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/里氏替换原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>可以在不破坏系统的情况下，用子类型替换类型。</p>
</blockquote>
<p><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a> 的第三个原则。该原则指出，如果组件依赖于类型，那么它应该能够使用该类型的子类型，而不会导致系统失败或者必须知道该子类型的详细信息。</p>
<p>举个例子，假设我们有一个方法，读取 XML 文档。如果该方法使用基类型 <strong>file</strong>，则从 <strong>file</strong> 派生的任何内容，都能用在该方法中。 如果 <strong>file</strong> 支持反向查找，并且 xml 解析器使用该函数，但是派生类型 <strong>network file</strong> 尝试反向查找时失败，则 <strong>network file</strong> 将违反该原则。</p>
<p>该原则与面向对象编程紧密相关，必须仔细建模、层次结构，以避免让系统用户混淆。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Orientated Programming</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a></li>
</ul>
<h3 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 (The Interface Segregation Principle)"></a>接口隔离原则 (The Interface Segregation Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/接口隔离原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>不应强制任何客户端依赖于它不使用的方法。</p>
</blockquote>
<p><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a> 的第四个原则。该原则指出组件的消费者不应该依赖于它实际上不使用的组件函数。</p>
<p>举一个例子，假设我们有一个方法，读取 XML 文档。它只需要读取文件中的字节，向前移动或向后移动。如果由于一个与文件结构不相关的功能发生更改（例如更新文件安全性的权限模型），需要更新此方法，则该原则已失效。文件最好实现 <strong>可查询流</strong> 接口，并让 XML 读取器使用该接口。</p>
<p>该原则与面向对象编程紧密相关，其中接口，层次结构和抽象类型用于不同组件的 <a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">minimise the coupling</a>。 <a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Duck typing</a> 是一种通过消除显式接口来强制执行该原则的方法。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Orientated Programming</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Duck Typing</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Decoupling</a></li>
</ul>
<h3 id="依赖反转原则-The-Dependency-Inversion-Principle"><a href="#依赖反转原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖反转原则 (The Dependency Inversion Principle)"></a>依赖反转原则 (The Dependency Inversion Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/依赖反转原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>高级模块不应该依赖于低级实现。</p>
</blockquote>
<p><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a> 的第五个原则。该原则指出，更高级别的协调组件不应该知道其依赖项的详细信息。</p>
<p>举个例子，假设我们有一个从网站读取元数据的程序。我们假设主要组件必须知道下载网页内容的组件，以及可以读取元数据的组件。如果我们考虑依赖反转，主要组件将仅依赖于可以获取字节数据的抽象组件，然后是一个能够从字节流中读取元数据的抽象组件，主要组件不需要了解 TCP、IP、HTTP、HTML 等。</p>
<p>这个原则很复杂，因为它似乎可以反转系统的预期依赖性（因此得名）。实践中，这也意味着，单独的编排组件必须确保抽象类型的正确实现被使用（例如在前面的例子中，必须提供元数据读取器组件、HTTP 文件下载功能和 HTML 元标签读取器）。然后，这涉及诸如 <a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Inversion of Control</a> 和 <a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Dependency Injection</a> 之类的模式。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Object-Orientated Programming</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#solid" target="_blank" rel="noopener">SOLID</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Inversion of Control</a></li>
<li><a href="https://github.com/nusr/hacker-laws-zh#todo" target="_blank" rel="noopener">Dependency Injection</a></li>
</ul>
<h3 id="不要重复你自己原则-The-DRY-Principle"><a href="#不要重复你自己原则-The-DRY-Principle" class="headerlink" title="不要重复你自己原则 (The DRY Principle)"></a>不要重复你自己原则 (The DRY Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Don' target="_blank" rel="noopener"t_repeat_yourself">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/一次且仅一次" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>系统中，每一块知识都必须是单一、明确而权威的。</p>
</blockquote>
<p>DRY 是 <strong>Do not Repeat Yourself</strong> 的缩写。这个原则旨在帮助开发人员减少代码的重复性，并将公共代码保存在一个地方。最初由安德鲁·亨特和戴夫·托马斯在 1999 年出版的《程序员修炼之道》中引用。</p>
<blockquote>
<p>与 DRY 相反的是 <em>WET</em>（功能实现两次或者喜欢打字 Write Everything Twice or We Enjoy Typing）。</p>
</blockquote>
<p>实际上，如果你在两个或更多的地方有相同的功能，你可以使用 DRY 原则将它们合并为一个，并在任何你需要的地方重复使用。</p>
<p>参见：</p>
<ul>
<li>《程序员修炼之道》<a href="https://en.wikipedia.org/wiki/The_Pragmatic_Programmer" target="_blank" rel="noopener">英文维基百科</a></li>
<li>《程序员修炼之道》<a href="https://book.douban.com/subject/1417047/" target="_blank" rel="noopener">豆瓣</a></li>
</ul>
<h3 id="KISS-原则-The-KISS-Principle"><a href="#KISS-原则-The-KISS-Principle" class="headerlink" title="KISS 原则 (The KISS Principle)"></a>KISS 原则 (The KISS Principle)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">英文维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/KISS原则" target="_blank" rel="noopener">中文维基百科</a></li>
</ul>
<blockquote>
<p>保持简单和直白。</p>
</blockquote>
<p>KISS 原则指明了如果大多数的系统能够保持简单而非复杂化，那么他们便能够工作在最佳状态。因此，简单性应该是设计时的关键指标，同时也要避免不必要的复杂度。这个短语最初出自 1960 年的美国海军飞机工程师凯利 · 约翰逊 (Kelly Johnson)。</p>
<p>这一原则的最好例证便是约翰逊给设计工程师一些实用工具的故事。那时的他们正面临着一个挑战，即他们参与设计的喷气式飞机必须能够让普通的机械师在战场上仅仅用这些工具进行维修，因此，“直白”这个词应指的是损坏的事物本身和修复用工具的复杂度两者之间的关系，而非工程师们自身的能力水平。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#盖尔定律-galls-law" target="_blank" rel="noopener">盖尔定律</a></li>
</ul>
<h3 id="你不需要它原则-YAGNI"><a href="#你不需要它原则-YAGNI" class="headerlink" title="你不需要它原则 (YAGNI)"></a>你不需要它原则 (YAGNI)</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/You_aren' target="_blank" rel="noopener"t_gonna_need_it">英文维基百科</a></li>
</ul>
<p>这是 <strong>*Y</strong>ou <strong>A</strong>ren’t <strong>G</strong>onna <strong>N</strong>eed <strong>I</strong>t* 的缩写。</p>
<blockquote>
<p>只有当你需要某些东西的时候，才去实现它们，而不是在你预见的时候。</p>
<p><a href="https://twitter.com/RonJeffries" target="_blank" rel="noopener">Ron Jeffries</a> 是极限编程的创始人之一以及书籍《Extreme Programming Installed》的作者。</p>
</blockquote>
<p>极限编程原则告诫开发人员，他们应该只实现当前所需的功能，并避免实现未来需要的功能，仅在必要时才实现。</p>
<p>遵守这一原则可以减小代码库大小，同时避免时间和生产力浪费在没有价值的功能上。</p>
<p>参见：</p>
<ul>
<li><a href="https://github.com/nusr/hacker-laws-zh#阅读清单" target="_blank" rel="noopener">阅读清单《极限编程安装》</a></li>
</ul>
<h3 id="分布式计算的谬论-The-Fallacies-of-Distributed-Computing"><a href="#分布式计算的谬论-The-Fallacies-of-Distributed-Computing" class="headerlink" title="分布式计算的谬论 (The Fallacies of Distributed Computing)"></a>分布式计算的谬论 (The Fallacies of Distributed Computing)</h3><p><a href="https://en.wikipedia.org/wiki/You_aren%https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="noopener">英文维基百科</a></p>
<p>又称 <em>网络计算的谬误</em>，这是一系列关于分布式计算的猜想（或者看法），这些猜想可能会引起软件开发中的失败。这些假设是：</p>
<ul>
<li>网络可靠</li>
<li>延迟为零</li>
<li>带宽无限</li>
<li>网络安全</li>
<li>拓扑恒定</li>
<li>有管理员</li>
<li>运输成本为零</li>
<li>网络为同构的</li>
</ul>
<p>前 4 各项目由 <a href="https://en.wikipedia.org/wiki/Bill_Joy" target="_blank" rel="noopener">Bill Joy</a> 和 <a href="https://twitter.com/aka_pugs" target="_blank" rel="noopener">Tom Lyon</a> 于 1991 左右提出。并被 <a href="https://en.wikipedia.org/wiki/James_Gosling" target="_blank" rel="noopener">James Gosling</a> 首次归类于“网络计算的谬误”；后 <a href="https://en.wikipedia.org/wiki/L._Peter_Deutsch" target="_blank" rel="noopener">L. Peter Deutsch</a> 添加了第 5、6、7 个谬误；90 年代末，Gosling 添加了最后一个谬误。</p>
<p>这些内容受到了 <a href="https://en.wikipedia.org/wiki/Sun_Microsystems" target="_blank" rel="noopener">太阳微系统 (Sun Microsystems)</a> 内部当时所发生的事情的启发。</p>
<p>在设计弹性代码的时候，应该仔细考虑这些谬误，并假设其中任何一个谬误都可能引起处理分布式系统的复杂性和现实性时的逻辑缺陷。</p>
<p>参见:</p>
<ul>
<li><a href="https://medium.com/baseds/foraging-for-the-fallacies-of-distributed-computing-part-1-1b35c3b85b53" target="_blank" rel="noopener">寻找分布式计算的谬误（第一部分） - Vaidehi Joshi on Medium</a></li>
<li><a href="http://java.sys-con.com/node/38665" target="_blank" rel="noopener">十年后，德意志 (Peter Deutsch) 的谬论</a></li>
</ul>
<h2 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h2><p>如果你觉得这些概念很有趣，你可能会喜欢以下书籍。</p>
<ul>
<li>《极限编程安装》<a href="https://www.goodreads.com/en/book/show/67834" target="_blank" rel="noopener">谷歌阅读地址</a> - 涵盖极限编程的核心原则。</li>
<li>《人月神话》<a href="https://www.goodreads.com/book/show/13629.The_Mythical_Man_Month" target="_blank" rel="noopener">谷歌阅读地址</a>、<a href="https://book.douban.com/subject/26358448/" target="_blank" rel="noopener">豆瓣地址</a> - 软件工程的经典书籍。这本书的中心主题就是<a href="https://github.com/nusr/hacker-laws-zh#布鲁克斯法则-brookss-law" target="_blank" rel="noopener">布鲁克斯法则</a> 。</li>
<li>《哥德尔、艾舍尔、巴赫：集异璧之大成》<a href="https://www.goodreads.com/book/show/24113.G_del_Escher_Bach" target="_blank" rel="noopener">谷歌阅读地址</a>、<a href="https://book.douban.com/subject/1291204/" target="_blank" rel="noopener">豆瓣地址</a> - 这本书很难分类。<a href="https://github.com/nusr/hacker-laws-zh#侯世达定律-hofstadters-law" target="_blank" rel="noopener">侯世达定律</a> 来自此书。</li>
<li>《呆伯特原则》<a href="https://www.goodreads.com/book/show/85574.The_Dilbert_Principle" target="_blank" rel="noopener">谷歌阅读地址</a> - 一本审视美国企业的漫画书，其作者创造了<a href="https://github.com/nusr/hacker-laws-zh#呆伯特法则-the-dilbert-principle" target="_blank" rel="noopener">呆伯特法则</a>。</li>
<li>《彼得原理》<a href="https://www.goodreads.com/book/show/890728.The_Peter_Principle" target="_blank" rel="noopener">谷歌阅读地址</a> - 一本专注于大型组织和人员管理的挑战的漫画书，也是<a href="https://github.com/nusr/hacker-laws-zh#彼得原理-the-peter-principle" target="_blank" rel="noopener">彼得原理</a>的来源。</li>
</ul>
<p>本文摘抄自 <a href="https://github.com/nusr/hacker-laws-zh" target="_blank" rel="noopener">https://github.com/nusr/hacker-laws-zh</a></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.asxing.com" rel="external nofollow noreferrer">HoldDie</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.asxing.com/2020/02/19/ruan-jian-gong-cheng-kai-fa-yuan-ze/">https://www.asxing.com/2020/02/19/ruan-jian-gong-cheng-kai-fa-yuan-ze/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://www.asxing.com" target="_blank">HoldDie</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%8E%9F%E5%88%99/">
                                    <span class="chip bg-color">原则</span>
                                </a>
                            
                                <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">
                                    <span class="chip bg-color">软件开发</span>
                                </a>
                            
                                <a href="/tags/%E5%AE%9A%E5%BE%8B/">
                                    <span class="chip bg-color">定律</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'c4e18e113d94091c8828',
        clientSecret: '891f04d80de6a77fd6eb60d1cbe792e916cde3ff',
        repo: 'asxing.github.io',
        owner: 'Asxing',
        admin: "asxing",
        id: '2020-02-19T22-06-03',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/23/gao-xing-neng-mysql-chuang-jian-gao-xing-neng-suo-yin-san/">
                    <div class="card-image">
                        
                        <img src="https://www.holddie.com/img/20200223222411.png" class="responsive-img" alt="高性能MySQL-创建高性能索引（三）">
                        
                        <span class="card-title">高性能MySQL-创建高性能索引（三）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

5.1　索引基础
索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。
创建一个
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/MySQL/" class="post-category">
                                    MySQL
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                    <a href="/tags/%E8%AF%BB%E4%B9%A6/">
                        <span class="chip bg-color">读书</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/19/enterprise-design-thinking/">
                    <div class="card-image">
                        
                        <img src="https://www.holddie.com/img/20200219222157.png" class="responsive-img" alt="Enterprise Design Thinking">
                        
                        <span class="card-title">Enterprise Design Thinking</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            学习什么是设计思维以及什么是创造经验很重要。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%9B%E9%80%A0%E6%80%9D%E7%BB%B4/" class="post-category">
                                    创造思维
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Design/">
                        <span class="chip bg-color">Design</span>
                    </a>
                    
                    <a href="/tags/Thinking/">
                        <span class="chip bg-color">Thinking</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="https://www.asxing.com" target="_blank">Asxing</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">479k</span>&nbsp;字
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "10";
                    var startDate = "30";
                    var startHour = "22";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/asxing" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:asxingking@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    

</body>

</html>
